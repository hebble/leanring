package com.learning.study.third;

/**
 * https://blog.csdn.net/banzhuanhu/article/details/106871495
 */
public class JvmLearning {
    /**
     1.什么情况下会发生栈内存溢出？
         (1)栈是线程私有的，栈的生命周期和线程一样，每个方法在执行的时候就会创建一个栈帧，它包含局部变量表、操作数栈、动态链接、方法出口等信息，局部变量表又包括基本数据类型和对象的引用；
         (2)当线程请求的栈深度超过了虚拟机允许的最大深度时，会抛出StackOverFlowError异常，方法递归调用肯可能会出现该问题；
         (3)调整参数-xss去调整jvm栈的大小

     2.详解JVM内存模型？
        具体情况见图jvm内存模型.png
        jvm将虚拟机分为5大区域，程序计数器、虚拟机栈、本地方法栈、java堆、方法区；
             (1)程序计数器：线程私有的，是一块很小的内存空间，作为当前线程的行号指示器，用于记录当前虚拟机正在执行的线程指令地址；
             (2)虚拟机栈：线程私有的，每个方法执行的时候都会创建一个栈帧，用于存储局部变量表、操作数、动态链接和方法返回等信息，当线程请求的栈深度超过了虚拟机允许的最大深度时，就会抛出StackOverFlowError；
             (3)本地方法栈：线程私有的，保存的是native方法的信息，当一个jvm创建的线程调用native方法后，jvm不会在虚拟机栈中为该线程创建栈帧，而是简单的动态链接并直接调用该方法；
             (4)堆：java堆是所有线程共享的一块内存，几乎所有对象的实例和数组都要在堆上分配内存，因此该区域经常发生垃圾回收的操作；
             (5)方法区：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据。即永久代，在jdk1.8中不存在方法区了，被元数据区替代了，原方法区被分成两部分；1：加载的类信息，2：运行时常量池；加载的类信息被保存在元数据区中，运行时常量池保存在堆中；

     3.JVM中一次完整的GC是什么样子的？对象如何晋升到老年代？
        具体见图堆空间内存划分.png
        java堆 = 新生代+老年代；
        新生代 = Eden(伊甸园区) + Suivivor(幸存者区)（S0 + S1），默认分配比例是8:1:1;
        当Eden区空间满了的时候，就会触发一次Minor GC，以收集新生代的垃圾，存活下来的对象会被分配到Survivor区
        大对象（需要大量连续内存空间的对象）会直接被分配到老年代， 如果对象在Eden中出生，并且在经历过一次Minor GC之后仍然存活，被分配到存活区的话，年龄+1，
        此后每经历过一次Minor GC并且存活下来，年龄就+1，当年龄达到15的时候，会被晋升到老年代；
        当老年代满了，而无法容纳更多对象的话，会触发一次full gc；full gc存储的是整个内存堆（包括年轻代和老年代）；
        Major GC是发生在老年代的GC，清理老年区，经常会伴随至少一次minor gc；

     4.Java中的垃圾回收算法？
        java中有四种垃圾回收算法，分别是标记清除法、标记整理法、复制算法、分代收集算法；
        （1）标记清除法：
            第一步：利用可达性去遍历内存，把存活对象和垃圾对象进行标记；
            第二步：在遍历一遍，将所有标记的对象回收掉；
            特点：效率不行，标记和清除的效率都不高；标记和清除后会产生大量的不连续的空间分片，可能会导致之后程序运行的时候需分配大对象而找不到连续分片而不得不触发一次GC；
        （2）标记整理法：
            第一步：利用可达性去遍历内存，把存活对象和垃圾对象进行标记；
            第二步：将所有的存活的对象向一段移动，将端边界以外的对象都回收掉；
            特点：适用于存活对象多，垃圾少的情况；需要整理的过程，无空间碎片产生；
        （3）复制算法：
            将内存按照容量大小分为大小相等的两块，每次只使用一块，当一块使用完了，就将还存活的对象移到另一块上，然后在把使用过的内存空间移除；
            特点：不会产生空间碎片；内存使用率极低；
        （4）分代收集算法：
            根据内存对象的存活周期不同，将内存划分成几块，java虚拟机一般将内存分成新生代和老生代，在新生代中，有大量对象死去和少量对象存活，
            所以采用复制算法，只需要付出少量存活对象的复制成本就可以完成收集；老年代中因为对象的存活率极高，没有额外的空间对他进行分配担保，
            所以采用标记清理或者标记整理算法进行回收；

     5.如何判断一个对象是否存活？
        判断一个对象是否存活，分为两种算法
            （1）引用计数法；
            （2）可达性分析算法；
        5.1 引用计数法：
            给每一个对象设置一个引用计数器，当有一个地方引用该对象的时候，引用计数器就+1，引用失效时，引用计数器就-1；当引用计数器为0的时候，就说明这个对象没有被引用，也就是垃圾对象，等待回收；
            缺点：无法解决循环引用的问题，当A引用B，B也引用A的时候，此时AB对象的引用都不为0，此时也就无法垃圾回收，所以一般主流虚拟机都不采用这个方法；
     */
}
