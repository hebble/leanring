package com.learning.study.third;

/**
 * https://blog.csdn.net/banzhuanhu/article/details/106871495
 * https://www.cnblogs.com/xfeiyun/p/15835733.html
 */
public class JvmLearning {
    /**
     1.什么情况下会发生栈内存溢出？
         (1)栈是线程私有的，栈的生命周期和线程一样，每个方法在执行的时候就会创建一个栈帧，它包含局部变量表、操作数栈、动态链接、方法出口等信息，局部变量表又包括基本数据类型和对象的引用；
         (2)当线程请求的栈深度超过了虚拟机允许的最大深度时，会抛出StackOverFlowError异常，方法递归调用肯可能会出现该问题；
         (3)调整参数-xss去调整jvm栈的大小

     2.详解JVM内存模型？
        具体情况见图jvm内存模型.png
        jvm将虚拟机分为5大区域，程序计数器、虚拟机栈、本地方法栈、java堆、方法区；
             (1)程序计数器：线程私有的，是一块很小的内存空间，作为当前线程的行号指示器，用于记录当前虚拟机正在执行的线程指令地址；
             (2)虚拟机栈：线程私有的，每个方法执行的时候都会创建一个栈帧，用于存储局部变量表、操作数、动态链接和方法返回等信息，当线程请求的栈深度超过了虚拟机允许的最大深度时，就会抛出StackOverFlowError；
             (3)本地方法栈：线程私有的，保存的是native方法的信息，当一个jvm创建的线程调用native方法后，jvm不会在虚拟机栈中为该线程创建栈帧，而是简单的动态链接并直接调用该方法；
             (4)堆：java堆是所有线程共享的一块内存，几乎所有对象的实例和数组都要在堆上分配内存，因此该区域经常发生垃圾回收的操作；
             (5)方法区：存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码数据。即永久代，在jdk1.8中不存在方法区了，被元数据区替代了，原方法区被分成两部分；1：加载的类信息，2：运行时常量池；加载的类信息被保存在元数据区中，运行时常量池保存在堆中；

     3.JVM中一次完整的GC是什么样子的？对象如何晋升到老年代？
        具体见图堆空间内存划分.png
        java堆 = 新生代+老年代；
        新生代 = Eden(伊甸园区) + Suivivor(幸存者区)（S0 + S1），默认分配比例是8:1:1;
        当Eden区空间满了的时候，就会触发一次Minor GC，以收集新生代的垃圾，存活下来的对象会被分配到Survivor区
        大对象（需要大量连续内存空间的对象）会直接被分配到老年代， 如果对象在Eden中出生，并且在经历过一次Minor GC之后仍然存活，被分配到存活区的话，年龄+1，
        此后每经历过一次Minor GC并且存活下来，年龄就+1，当年龄达到15的时候，会被晋升到老年代；
        当老年代满了，而无法容纳更多对象的话，会触发一次full gc；full gc存储的是整个内存堆（包括年轻代和老年代）；
        Major GC是发生在老年代的GC，清理老年区，经常会伴随至少一次minor gc；

     4.Java中的垃圾回收算法？
        java中有四种垃圾回收算法，分别是标记清除法、标记整理法、复制算法、分代收集算法；
        （1）标记清除法：
            第一步：利用可达性去遍历内存，把存活对象和垃圾对象进行标记；
            第二步：在遍历一遍，将所有标记的对象回收掉；
            特点：效率不行，标记和清除的效率都不高；标记和清除后会产生大量的不连续的空间分片，可能会导致之后程序运行的时候需分配大对象而找不到连续分片而不得不触发一次GC；
        （2）标记整理法：
            第一步：利用可达性去遍历内存，把存活对象和垃圾对象进行标记；
            第二步：将所有的存活的对象向一段移动，将端边界以外的对象都回收掉；
            特点：适用于存活对象多，垃圾少的情况；需要整理的过程，无空间碎片产生；
        （3）复制算法：(用于新生代)
            将内存按照容量大小分为大小相等的两块，每次只使用一块，当一块使用完了，就将还存活的对象移到另一块上，然后在把使用过的内存空间移除；
            特点：不会产生空间碎片；内存使用率极低；
        （4）分代收集算法：
            根据内存对象的存活周期不同，将内存划分成几块，java虚拟机一般将内存分成新生代和老生代，在新生代中，有大量对象死去和少量对象存活，
            所以采用复制算法，只需要付出少量存活对象的复制成本就可以完成收集；老年代中因为对象的存活率极高，没有额外的空间对他进行分配担保，
            所以采用标记清理或者标记整理算法进行回收；

     5.如何判断一个对象是否存活？
        判断一个对象是否存活，分为两种算法
            （1）引用计数法；
            （2）可达性分析算法；
        5.1 引用计数法：
            给每一个对象设置一个引用计数器，当有一个地方引用该对象的时候，引用计数器就+1，引用失效时，引用计数器就-1；当引用计数器为0的时候，就说明这个对象没有被引用，也就是垃圾对象，等待回收；
            缺点：无法解决循环引用的问题，当A引用B，B也引用A的时候，此时AB对象的引用都不为0，此时也就无法垃圾回收，所以一般主流虚拟机都不采用这个方法；
        5.2 可达性分析法:
            从一个被称为GC Roots的对象向下搜索，如果一个对象到GC Roots没有任何引用链相连接时，说明此对象不可用，在java中可以作为GC Roots的对象有以下几种：
                (1)虚拟机栈中引用的对象
                (2)方法区类静态属性引用的变量
                (3)方法区常量池引用的对象
                (4)本地方法栈JNI引用的对象
            但一个对象满足上述条件的时候，不会马上被回收，还需要进行两次标记；
                第一次标记：判断当前对象是否有finalize()方法并且该方法没有被执行过，若不存在则标记为垃圾对象，等待回收；若有的话，则进行第二次标记；
                第二次标记将当前对象放入F-Queue队列，并生成一个finalize线程去执行该方法，虚拟机不保证该方法一定会被执行，这是因为如果线程执行缓慢或进入了死锁，会导致回收系统的崩溃；
                如果执行了finalize方法之后仍然没有与GC Roots有直接或者间接的引用，则该对象会被回收；

     6.有哪几种垃圾回收器，有哪些优缺点？cms和g1的区别？
        垃圾回收器主要分为以下几种：Serial、ParNew、Parallel Scavenge、Serial Old、Parallel Old、CMS、G1；
             Serial:单线程的收集器，收集垃圾时，必须stop the world，(暂停一切线程)使用复制算法。
             ParNew:Serial收集器的多线程版本，也需要stop the world，复制算法.
             ParallelScavenge:新生代收集器，复制算法的收集器，并发的多线程收集器，目标是达到一个可控的吞吐量，和ParNew的最大区别是GC自动调节策略；虚拟机会根据系统的运行状态收集性能监控信息，动态设置这些参数，以提供最优停顿时间和最高的吞吐量；
             Serial Old：Serial收集器的老年代版本，单线程收集器，使用标记整理算法。
             Parallel Old：是Parallel Scavenge收集器的老年代版本，使用多线程，标记-整理算法。
             CMS:是一种以获得最短回收停顿时间为目标的收集器，(用户线程和GC线程并发执行)标记清除算法，
                运作过程：初始标记(STW)->并发标记(和用户线程并行)->并发预处理->重新标记(STW)->并发清除->重置
                收集结束会产生大量空间碎片；
             G1:标记整理算法实现，运作流程主要包括以下：
                初始标记(STW)->并发标记->重新标记(STW)，筛选回收。不会产生空间碎片，可以精确地控制停顿；G1将整个堆分为大小相等的多个Region（区域），G1跟踪每个区域的垃圾大小，在后台维护一个优先级列表，每次根据允许的收集时间，优先回收价值最大的区域，已达到在有限时间内获取尽可能高的回收效率；
        具体见图垃圾回收器关系图.png / 垃圾回收器分类.jpg
        jdk7、8、9默认垃圾回收器
             (1)jdk1.7 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）
             (2)jdk1.8 默认垃圾收集器Parallel Scavenge（新生代）+Parallel Old（老年代）
             (3)jdk1.9 默认垃圾收集器G1

     7.CMS垃圾回收器
        7.1 CMS介绍(JDK1.5)
            CMS的全称：Concurrent Mark Sweep，翻译过来是并发标记清除
            用CMS对比上面的垃圾收集器(Seria和Parallel和parNew)：它最大的不同点就是并发：在GC线程工作的时候，用户线程不会完全停止，用户线程在部分场景下与GC线程一起并发执行。
            但是，要理解的是，无论是什么垃圾收集器，Stop The World是一定无法避免的！
            CMS只是在部分的GC场景下可以让GC线程与用户线程并发执行
            CMS的设计目标是为了避免老年代 GC出现长时间的卡顿（Stop The World）
        7.2 CMS的工作流程
            CMS可以简单分为5个步骤：初始标记、并发标记、（并发预清理）、重新标记以及并发清除
            从步骤就不难看出，CMS主要是实现了标记清除垃圾回收算法
            (1)初始标记:
                在这个阶段中，程序中的所有工作线程都将会因为”Stop-The-World"机制而出现短暂的暂停，这个阶段的主要任务仅仅只是标记出GC Roots能直接关联到的对象。
                一旦标记完成之后就会恢复之前被暂停的所有应用线程。由于直接关联对象比较小，所以这里的速度非常快。
            (2)并发标记:
                从GC Roots的直接关联对象开始遍历整个对象图的过程，这个过程耗时较长但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行。
            (3)并发预清理:
                这个阶段会扫描可能由于并发标记时导致老年代发生变化的对象，会再扫描一遍标记为dirty的卡页对于新生代的对象，我们还是得遍历新生代来看看在并发标记过程中有没有对象引用了老年代
            (4)重新标记:
                由于在并发标记阶段中，程序的工作线程会和垃圾收集线程同时运行或者交叉运行，因此为了修正并发标记期间，因用户线程继续运行而导致标记产生变动的那一部分
                对象的标记记录，这个阶段的停顿时间通常会比初始标记阶段稍长一些，但也远比并发标记阶段的时间短
            (5)并发清除
                此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间。由于不需要移动存活对象，所以这个阶段也是可以与用户线程同时并发的。
        7.3 跨代引用的问题
            针对老年代的对象，其实还是可以借助类card table的存储（将老年代对象发生变化所对应的卡页标记为dirty）
        7.4 CMS的缺点
             (1)空间需要预留：
                CMS垃圾收集器可以一边回收垃圾，一边处理用户线程，那需要在这个过程中保证有充足的内存空间供用户使用。如果CMS运行过程中预留的空间不够用了，会报错（Concurrent Mode Failure），
                这时会启动 Serial Old垃圾收集器进行老年代的垃圾回收，会导致停顿的时间很长。显然啦，空间预留多少，肯定是有参数配置的。
             (2)浮动垃圾：
                由于垃圾回收和用户线程是同时进行的，在进行标记或者清除的同时，用户的线程还会去改变对象的引用，使得原来某些对象不是垃圾，但是当 CMS 进行清理的时候变成了垃圾，CMS 收集器无法收集，
                只能等到下一次 GC。CMS 收集器无法处理浮动垃圾（Floating Garbage），可能出现 “Concurrent Mode Failure” 失败而导致另一次 Full GC 的产生。如果在应用中老年代增长不是太
                快，可以适当调高参数 - XX:CMSInitiatingOccupancyFraction 的值来提高触发百分比，以便降低内存回收次数从而获取更好的性能。
             (3)内存碎片问题：
                CMS本质上是实现了标记清除算法的收集器（从过程就可以看得出），这会意味着会产生内存碎片。由于碎片太多，又可能会导致内存空间不足所触发full GC，CMS一般会在触发full GC这个过程对
                碎片进行整理。整理涉及到移动/标记，那这个过程肯定会Stop The World的，如果内存足够大（意味着可能装载的对象足够多），那这个过程卡顿也是需要一定的时间的。

     8.G1垃圾回收器
        8.1 G1介绍（Garbage first）(JDK1.9及其以后采取的默认垃圾回收器)
            具体可见图G1中Region分布示例图.jpg
            (1)G1主要面向的是服务端的垃圾回收器。在G1之前，JVM的主要垃圾回收器采用的是物理分代的思想，将内存区域严格的划分成年轻代（young GC）和老年代（major GC），
                然后针对于年轻代和老年代使用不同的垃圾回收器进行GC操作，直到G1，G1采用的是对整个堆进行回收，并且G1使用的分区region思想将内存划分成了许多的分区。
            (2)虽说G1不使用严格将内存分为年轻代和老年代，但是在逻辑层面G1还是将分区region贴上了标签Eden，Survivor，Old，也是一种分代的思想，并且G1针对于特别大的对象
                （当一个对象会占据一个分区的一般以上空间G1称为大对象）会将该大对象用一段连续的多个Humongous分区（专门存放大对象）存放。G1的大多数行为都会将Humougous分区
                判定为老年代看待。每个region的大小可以通过XX:G1HeapRegionSize设定（取值范围1~32MB），且为2的N次幂。
        8.2 G1的停顿时间控制(用户自定义停顿时间)
            如果用户停顿时间过长：那么会导致用户线程停止很长时间，降低吞吐量。
            如果用户停顿时间过短：那么会导致一次GC回收不了太多的垃圾对象，则会导致频繁GC，也会降低吞吐量。
            G1的还有一个特点就是用户可以通过设置-XX:MaxGCPauseMills来设置用户允许的停顿时间（默认为200ms），G1会根据这个时间尽可能的回收垃圾，所以这也是G1是比较全能的原因。
            针对用户自定义停顿时间我们可以猜想到，G1很可能无法完全回收所有垃圾（因为设定了一个时间），但是G1会尽可能的多收集垃圾。有点类似于老板给员工制定一个KPI，要求高就多收集点，
            要求低就少收集点。这也是G1的一个回收特点：并不是回收全部垃圾，而是尽可能在用户规定得停顿时间内尽可能回收垃圾多的region。
        8.3 G1如何实现尽可能回收最多垃圾region？
            G1之所以能够建立预测停顿时间的模型，依赖于G1是针对于分区region进行整体回收，即每次回收都是以region为单位。那么G1如何判断哪些region的回收率高（即垃圾多）：
            G1收集器会跟踪每个region里面垃圾堆积的价值（即回收该region所获的空间和所需时间的价值），然后再后台维护一个优先级列表，每次根据该优先级列表进行回收（优先处
            理优先级高的region），这也是Garbage First的由来。
        8.4 如果存在跨代引用如何解决？
            针对于年轻代的region我们每次都会进行回收，所以不需要考虑年轻代指向老年代。
            针对于老年代指向年轻代的引用我们如何选择（如果不管则使用整个堆的GC root扫描），这里提出的思想是记忆集rset（remember set）
                G1是对每个region维护了一个rset，记忆集中维护了指向自己的region的指针，并且标记指针分别在那些卡页的范围之内。由于G1使用了很多的region（每个region都有一个rset），
                所以G1使用了较高的内存，基本占用Java对内存的10%~20%的额外内存来维持收集器的工作。
        8.5 G1垃圾收集的工作流程
             G1的收集过程主要分为四步：
                 (1)初始标记
                    仅仅标记GC roots能直接关联到的对象。该步骤需要STW，但是时间极短。
                 (2)并发标记
                    从GC roots使用可达性算法，对堆内存中对象进行标记（三色标记法），递归扫描整个堆。该步骤耗时过长，是与用户业务程序并发执行。
                 (3)重新标记
                    对用户线程短暂的STW，用于处理并发标记中对象的一些变更情况的最终确定。
                 (4)筛选回收
                    G1会根据用户规定的停顿时间，最大的回收region，将需要被回收的region复制到空白region中，再将原region全部回收。该步骤也需要STW，因为涉及到了对象的移动（一个region到另一个region）。
        8.6 三色标记
             黑色：自身及其子对象已经被标记。
             灰色：自身已经被标记，但是子对象没有完全被标记
             白色：自身未被标记，如果标记结束后仍然为白色，则是垃圾对象。

     9.类加载
        什么是类加载？
            虚拟机把描述类的数据加载到内存里面，并对数据进行校验、解析和初始化，最终变成可以被虚拟机直接使用的class对象；
        类加载的过程？
            主要分为以下几个过程：加载、验证、准备、解析、初始化；
                加载：
                     (1)通过类的全限定性类名获取该类的二进制流；
                     (2)将该二进制流的静态存储结构转为方法区的运行时数据结构；
                     (3)在堆中为该类生成一个class对象；
                验证：验证该class文件中的字节流信息复合虚拟机的要求，不会威胁到jvm的安全；
                准备：为class对象的静态变量分配内存，初始化其初始值；
                解析：该阶段主要完成符号引用转化成直接引用；(换成具体的引用的内存地址)
                初始化：到了初始化阶段，才开始执行类中定义的java代码；初始化阶段是调用类构造器的过程；

     10.什么是类加载器，常见的类加载器有哪些？
        类加载器是指：通过一个类的全限定性类名获取该类的二进制字节流叫做类加载器；
        常见的类加载器分为以下四种：
             启动类加载器：用来加载java核心类库，无法被java程序直接引用；
             扩展类加载器：用来加载java的扩展库，java的虚拟机实现会提供一个扩展库目录，该类加载器在扩展库目录里面查找并加载java类；
             系统类加载器(应用程序类加载器)：它根据java的类路径来加载类，一般来说，java应用的类都是通过它来加载的；
             自定义类加载器：由java语言实现，继承自ClassLoader；

     11.什么是双亲委派模型？
        当一个类加载器收到一个类加载的请求，他首先不会尝试自己去加载，而是将这个请求委派给父类加载器去加载，
        只有父类加载器在自己的搜索范围类查找不到给类时，子加载器才会尝试自己去加载该类；
        具体见图双亲委派模型顺序.png

     12.为什么需要双亲委派模型？
        为了防止内存中出现多个相同的字节码；因为如果没有双亲委派的话，用户就可以自己定义一个java.lang.String类，那么就无法保证类的唯一性；

     13.怎么打破双亲委派模型？
        自定义类加载器，继承ClassLoader类，重写loadClass方法和findClass方法；

     14.强引用、软引用、弱引用、虚引用的区别？
         (1)强引用：
            强引用是我们使用最广泛的引用，如果一个对象具有强引用，那么垃圾回收期绝对不会回收它，当内存空间不足时，垃圾回收器宁愿抛出OutOfMemoryError，也不会回收具有强引用的对象；我们可以通过显示
            的将强引用对象置为null，让gc认为该对象不存在引用，从而来回收它；
         (2)软引用：
            软引用是用来描述一些有用但不是必须的对象，在java中用SoftReference来表示，当一个对象只有软应用时，只有当内存不足时，才会回收它；软引用可以和引用队列联合使用，如果软引用所引用的对象被
            垃圾回收器所回收了，虚拟机会把这个软引用加入到与之对应的引用队列中；
         (3)弱引用：
            弱引用是用来描述一些可有可无的对象，在java中用WeakReference来表示，在垃圾回收时，一旦发现一个对象只具有软引用的时候，无论当前内存空间是否充足，都会回收掉该对象；弱引用可以和引用队列
            联合使用，如果弱引用所引用的对象被垃圾回收了，虚拟机会将该对象的引用加入到与之关联的引用队列中；
         (4)虚引用：虚引用就是一种可有可无的引用，无法用来表示对象的生命周期，任何时候都可能被回收，虚引用主要使用来跟踪对象被垃圾回收的活动，虚引用和软引用与弱引用的区别在于：虚引用必须和引用队
            列联合使用；在进行垃圾回收的时候，如果发现一个对象只有虚引用，那么就会将这个对象的引用加入到与之关联的引用队列中，程序可以通过发现一个引用队列中是否已经加入了虚引用，来了解被引用的对
            象是否需要被进行垃圾回收；
     */
}
