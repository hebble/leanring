package com.learning.study.redis;

public class RedisLearning {
    /**
     * 1.redis概念
     * 与MySQL数据库不同的是，Redis的数据是存在内存中的。它的读写速度非常快，每秒可以处理超过10万次读写操作。因此redis被广泛应用于缓存，另外，Redis也经常用来做分布式锁。除此之外，Redis支持事务、持久化、LUA 脚本、LRU 驱动事件、多种集群方案。
     *
     * 2.redis数据结构
     *      String（字符串）
     *      Hash（哈希）
     *      List（列表）
     *      Set（集合）
     *      zset（有序集合）
     * 3.Redis为什么这么快？
     *      基于内存存储实现
     *      高效的数据结构
     *      合理的数据编码
     *      合理的线程模型
     *          I/O 多路复用(I/O ：网络 I/O, 多路 ：多个网络连接, 复用：复用同一个线程。)
     *          单线程模型(Redis是单线程模型的，而单线程避免了CPU不必要的上下文切换和竞争锁的消耗)
     *      虚拟内存机制
     *          虚拟内存机制就是暂时把不经常访问的数据(冷数据)从内存交换到磁盘中，从而腾出宝贵的内存空间用于其它需要访问的数据(热数据)。通过VM功能可以实现冷热数据分离，使热数据仍在内存中、冷数据保存到磁盘。这样就可以避免因为内存不足而造成访问速度下降的问题。
     */

    /**
     * 4. 什么是缓存击穿、缓存穿透、缓存雪崩？
     *  4.1缓存穿透
     *      指查询一个一定不存在的数据，由于缓存是不命中时需要从数据库查询，查不到数据则不写入缓存，这将导致这个不存在的数据每次请求都要到数据库去查询，进而给数据库带来压力。
     *      如何避免缓存穿透呢？
     *          1.如果是非法请求，我们在API入口，对参数进行校验，过滤非法值。
     *          2.如果查询数据库为空，我们可以给缓存设置个空值，或者默认值。但是如有有写请求进来的话，需要更新缓存哈，以保证缓存一致性，同时，最后给缓存设置适当的过期时间。（业务上比较常用，简单有效）
     *          3.使用布隆过滤器快速判断数据是否存在。即一个查询请求过来时，先通过布隆过滤器判断值是否存在，存在才继续往下查。
     *  4.2缓存雪奔问题
     *      指缓存中数据大批量到过期时间，而查询数据量巨大，请求都直接访问数据库，引起数据库压力过大甚至down机。
     *      解决办法:
     *          1.可通过均匀设置过期时间解决, 如采用一个较大固定值+一个较小的随机值，5小时+0到1800秒酱紫。
     *          2.Redis 故障宕机也可能引起缓存雪奔。这就需要构造Redis高可用集群啦
     *  4.3缓存击穿问题
     *      指热点key在某个时间点过期的时候，而恰好在这个时间点对这个Key有大量的并发请求过来，从而大量的请求打到db。有些文章认为它俩区别，是区别在于击穿针对某一热点key缓存，雪奔则是很多key。
     *      解决办法:
     *          1.使用互斥锁方案。缓存失效时，不是立即去加载db数据，而是先使用某些带成功返回的原子操作命令，如(Redis的setnx）去操作，成功的时候，再去加载db数据库数据和设置缓存。否则就去重试获取缓存。
     *          2. “永不过期”，是指没有设置过期时间，但是热点数据快要过期时，异步线程去更新和设置过期时间。
     */

    /**
     * 5. 什么是热Key问题，如何解决热key问题
     *      在Redis中，我们把访问频率高的key，称为热点key。如果某一热点key的请求到服务器主机时，由于请求量特别大，可能会导致主机资源不足，甚至宕机，从而影响正常的服务。
     *      如何解决热key问题？
     *
     */
}
