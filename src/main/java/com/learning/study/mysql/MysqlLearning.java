package com.learning.study.mysql;

public class MysqlLearning {
    /**
     * 1、数据库的常用范式：
     *      第一范式（1NF）：指表的列不可再分，数据库中表的每一列都是不可分割的基本数据项，同一列中不能有多个值；
     *      第二范式（2NF）：在 1NF 的基础上，还包含两部分的内容：一是表必须有一个主键；二是表中非主键列必须完全依赖于主键，不能只依赖于主键的一部分；
     *      第三范式（3NF）：在 2NF 的基础上，消除非主键列对主键的传递依赖，非主键列必须直接依赖于主键。
     *      BC范式（BCNF）：在 3NF 的基础上，消除主属性对于码部分的传递依赖
     *
     *2.SQL语句的执行过程
     *      2.1、客户端的数据库驱动与数据库连接池：
     *          （1）客户端与数据库进行通信前，通过数据库驱动与MySQL建立连接，建立完成之后，就发送SQL语句
     *          （2）为了减少频繁创建和销毁连接造成系统性能的下降，通过数据库连接池维护一定数量的连接线程，当需要进行连接时，就直接从连接池中获取，使用完毕之后，再归还给连接池。常见的数据库连接池有 Druid、C3P0、DBCP
     *      2.2、MySQL架构的Server层的执行过程：
     *          （1）连接器：主要负责跟客户端建立连接、获取权限、维持和管理连接
     *          （2）查询缓存：优先在缓存中进行查询，如果查到了则直接返回，如果缓存中查询不到，在去数据库中查询。
     *                  MySQL缓存是默认关闭的，也就是说不推荐使用缓存，并且在MySQL8.0 版本已经将查询缓存的整块功能删掉了
     *          （3）解析器/分析器：分析器的工作主要是对要执行的SQL语句进行词法解析、语法解析，最终得到抽象语法树，然后再使用预处理器对抽象语法树进行语义校验，判断抽象语法树中的表是否存在，如果存在的话，在接着判断select投影列字段是否在表中存在等。
     *          （4）优化器：主要将SQL经过词法解析、语法解析后得到的语法树，通过数据字典和统计信息的内容，再经过一系列运算 ，最终得出一个执行计划，包括选择使用哪个索引
     *          （5）执行器：根据一系列的执行计划去调用存储引擎提供的API接口去调用操作数据，完成SQL的执行。
     *      2.3、Innodb存储引擎的执行过程
     *          （1）首先MySQL执行器根据 执行计划 调用存储引擎的API查询数据
     *          （2）存储引擎先从缓存池buffer pool中查询数据，如果没有就会去磁盘中查询，如果查询到了就将其放到缓存池中
     *          （3）在数据加载到 Buffer Pool 的同时，会将这条数据的原始记录保存到 undo 日志文件中
     *          （4）innodb 会在 Buffer Pool 中执行更新操作
     *          （5）更新后的数据会记录在 redo log buffer 中
     *          （6）提交事务在提交的同时会做以下三件事
     *          （7）（第一件事）将redo log buffer中的数据刷入到redo log文件中
     *          （8）（第二件事）将本次操作记录写入到 bin log文件中
     *          （9）（第三件事）将bin log文件名字和更新内容在 bin log 中的位置记录到redo log中，同时在 redo log 最后添加 commit 标记
     *          （10）使用一个后台线程，它会在某个时机将我们Buffer Pool中的更新后的数据刷到 MySQL 数据库中，这样就将内存和数据库的数据保持统一了
     *      备注: buffer pool 和 查询缓存的区别：
     *          （1）查询缓存：查询缓存位于Server层，MySQL Server首选会从查询缓存中查看是否曾经执行过这个SQL，如果曾经执行过的话，之前执行的查询结果会以Key-Value的形式保存在查询缓存中。key是SQL语句，value是查询结果。我们将这个过程称为查询缓存！
     *          （2）Buffer Pool位于存储引擎层。Buffer Pool就是MySQL存储引擎为了加速数据的读取速度而设计的缓冲机制
     *
     * 3.常用的存储引擎？InnoDB与MyISAM的区别？
     *      存储引擎是对底层物理数据执行实际操作的组件，为Server服务层提供各种操作数据的API。常用的存储引擎有InnoDB、MyISAM、Memory。这里我们主要介绍InnoDB 与 MyISAM 的区别：
     *      （1）事务：MyISAM不支持事务，InnoDB支持事务
     *      （2）锁级别：MyISAM只支持表级锁，InnoDB支持行级锁和表级锁，默认使用行级锁，但是行锁只有通过索引查询数据才会使用，否则将使用表锁。行级锁在每次获取锁和释放锁的操作需要消耗比表锁更多的资源。使用行锁可能会存在死锁的情况，但是表级锁不存在死锁
     *      （3）主键和外键：MyISAM 允许没有任何索引和主键的表存在，不支持外键。InnoDB的主键不能为空且支持主键自增长，如果没有设定主键或者非空唯一索引，就会自动生成一个6字节的主键，支持外键完整性约束
     *      （4）索引结构：MyISAM 和 InnoDB 都是使用B+树索引，MyISAM的主键索引和辅助索引的Data域都是保存行数据记录的地址。但是InnoDB的主键索引的Data域保存的不是行数据记录的地址，而是保存该行的所有数据内容，而辅助索引的Data域保存的则是主索引的值。
     *      （5）全文索引：MyISAM支持全文索引，InnoDB在5.6版本之前不支持全文索引，5.6版本及之后的版本开始支持全文索引
     *      （6）表的具体行数：
     *          ① MyISAM：保存有表的总行数，如果使用 select count() from table 会直接取出出该值，不需要进行全表扫描。
     *          ② InnoDB：没有保存表的总行数，如果使用 select count() from table 需要会遍历整个表，消耗相当大。
     *      （7）存储结构：
     *          ① MyISAM会在磁盘上存储成三个文件：.frm文件存储表定义，.MYD文件存储数据，.MYI文件存储索引。
     *          ② InnoDB：把数据和索引存放在表空间里面，所有的表都保存在同一个数据文件中，InnoDB表的大小只受限于操作系统文件的大小，一般为2GB。
     *      （8）存储空间：
     *          ① MyISAM：可被压缩，存储空间较小。支持三种不同的存储格式：静态表(默认，但是注意数据末尾不能有空格，会被去掉)、动态表、压缩表。
     *          ② InnoDB：需要更多的内存和存储，它会在主内存中建立其专用的缓冲池用于高速缓冲数据和索引。
     *      （9）适用场景：
     *          ① 如果需要提供回滚、崩溃恢复能力的ACID事务能力，并要求实现行锁级别并发控制，InnoDB是一个好的选择；
     *          ② 如果数据表主要用来查询记录，读操作远远多于写操作且不需要数据库事务的支持，则MyISAM引擎能提供较高的处理效率；
     *
     *      备注：在mysql8.0版本中已经废弃了MyISAM存储引擎
     *
     * 4.数据库中的锁机制？
     *      当数据库中多个事务并发存取同一数据的时候，若对并发操作不加控制就可能会读取和存储不正确的数据，破坏数据库的一致性。MySQL锁机制的基本工作原理就是，事务在修改数据库之前，需要先获得相应的锁，获得锁的事务才可以修改数据；在该事务操作期间，这部分的数据是锁定，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。
     *      按照不同的分类方式，锁的种类可以分为以下几种：
     *          按锁的粒度划分：表级锁、行级锁、页级锁；
     *          按锁的类型划分：共享（锁S锁）、排他锁（X锁）；
     *          按锁的使用策略划分：乐观锁、悲观锁；
     *      4.1表级锁、行级锁、页级锁
     *          表级锁：最大粒度的锁级别，发生锁冲突的概率最高，并发度最低，但开销小，加锁快，不会出现死锁；
     *          行级锁：最小粒度的锁级别，发生锁冲突的概率最小，并发度最高，但开销大，加锁慢，会发生死锁；
     *          页级锁：锁粒度界于表级锁和行级锁之间，对表级锁和行级锁的折中，并发度一般。开销和加锁时间也界于表锁和行锁之间，会出现死锁；
     *         InnoDB存储引擎支持行级锁和表级锁，默认情况下使用行级锁，但只有通过索引进行查询数据，才使用行级锁，否就使用表级锁。
     *      4.2InnoDB的行锁有两种类型：
     *          共享锁（S锁、读锁）：多个事务可以对同一数据行共享一把S锁，但只能进行读不能修改；
     *          排它锁（X锁、写锁）：一个事务获取排它锁之后，可以对锁定范围内的数据行执行写操作，在锁定期间，其他事务不能再获取这部分数据行的锁（共享锁、排它锁），只允许获取到排它锁的事务进行更新数据。
     *          对于update，delete，insert 操作，InnoDB会自动给涉及的数据行加排他锁；对于普通SELECT语句，InnoDB不会加任何锁。
     *
     * 5.MySQL索引的实现原理
     *      索引本质上就是一种通过减少查询需要遍历行数，加快查询性能的数据结构，避免数据库进行全表扫描，好比书的目录，让你更快的找到内容。
     *
     * 6.索引的使用场景
     *      （1）在哪些列上面创建索引：
     *          WHERE子句中经常出现的列上面创建索引，加快条件的判断速度。
     *          按范围存取的列或者在group by或order by中使用的列，因为索引已经排序，这样可以利用索引加快排序查询时间。
     *          经常用于连接的列上，这些列主要是一些外键，可以加快连接的速度；
     *          作为主键的列上，强制该列的唯一性和组织表中数据的排列结构；
     *      （2）不在哪些列建索引？
     *          区分度不高的列。由于这些列的取值很少，例如性别，在查询的结果中，结果集的数据行占了表中数据行的很大比例，即需要在表中搜索的数据行的比例很大。增加索引，并不能明显加快检索速度。
     *          在查询中很少的列不应该创建索引。由于这些列很少使用到，但增加了索引，反而降低了系统的维护速度和增大了空间需求。
     *          当添加索引造成修改成本的提高 远远大于 检索性能的提高时，不应该创建索引。当增加索引时，会提高检索性能，但是会降低修改性能。当减少索引时，会提高修改性能，降低检索性能。
     *          定义为text, image和bit数据类型的列不应该增加索引。这些列的数据量要么相当大，要么取值很少。
     *
     * 7.索引的分类
     *      （1）普通索引、唯一索引、主键索引、全文索引、组合索引。
     *          普通索引：最基本的索引，没有任何限制
     *          唯一索引：但索引列的值必须唯一，允许有空值，可以有多个NULL值。如果是组合索引，则列值的组合必须唯一。
     *          主键索引：一种特殊的唯一索引，不允许有空值。
     *          全文索引：全文索引仅可用于 MyISAM 表，并只支持从CHAR、VARCHAR或TEXT类型，用于替代效率较低的like 模糊匹配操作，而且可以通过多字段组合的全文索引一次性全模糊匹配多个字段。
     *          组合索引：主要是为了提高mysql效率，创建组合索引时应该将最常用作限制条件的列放在最左边，依次递减。
     *      （2）聚簇索引与非聚簇索引：
     *          如果按数据存储的物理顺序与索引值的顺序分类，可以将索引分为聚簇索引与非聚簇索引两类：
     *          聚簇索引：表中数据存储的物理顺序与索引值的顺序一致，一个基本表最多只能有一个聚簇索引，更新聚簇索引列上的数据时，往往导致表中记录的物理顺序的变更，代价较大，因此对于经常更新的列不宜建立聚簇索引
     *          非聚簇索引：表中数据的物理顺序与索引值的顺序不一致的索引组织，一个基本表可以有多个非聚簇索引。
     *
     * 8.索引失效的情况
 *             1.未遵循最佳左前缀规则导致索引失效
     *         2.计算、函数、类型转换(自动或手动)导致索引失效
     *         3.范围条件右边列索引可能失效(当Mysql发现通过索引扫描的行记录数超过全表的10%-30%时，优化器可能会放弃走索引，自动变成全表扫描)
     *            索引最多用于一个范围列，如果查询条件中有两个范围列则无法全用到索引。
     *         4.不等于(!=)会导致索引失效
     *         5.is null可以用到索引，is not null不能用到索引
     *         6.like以通配符%开头索引失效
     *         7.or 前的列建立了索引 or后面的列没有建立索引 会导致索引失效
     *         8.不同字符集进行比较前需要进行转换，会导致索引失效
     *
     * 9.索引的数据结构？
     *      索引的数据结构主要有B+树和哈希表，对应的索引分别为B+树索引和哈希索引。InnoDB引擎的索引类型有B+树索引和哈希索引，默认的索引类型为B+树索引。
     *      (1)B+树索引
     *          在B+树中，所有的记录节点都是按照键值大小的顺序放在叶子节点上, 因为B+树具有有序性，并且所有的数据都存放在叶子节点，所以查找的效率非常高，并且支持排序和范围查找。
     *          B+树的索引又可以分为主索引和辅助索引。其中主索引为聚簇索引，辅助索引为非聚簇索引。
     *          聚簇索引
     *              聚簇索引是以主键作为B+ 树索引的键值所构成的B+树索引，聚簇索引的叶子节点存储着完整的数据记录；
     *          非聚簇索引
     *              非聚簇索引是以非主键的列作为B+树索引的键值所构成的B+树索引，非聚簇索引的叶子节点存储着主键值
     *              所以使用非聚簇索引进行查询时，会先找到主键值，然后到根据聚簇索引找到主键对应的数据域。
     *       (2)哈希索引
     *          哈希索引是基于哈希表实现的，对于每一行数据，存储引擎会对索引列通过哈希算法进行哈希计算得到哈希码，并且哈希算法要尽量保证不同的列值计算出的哈希码值是不同的，
     *          将哈希码的值作为哈希表的key值，将指向数据行的指针作为哈希表的value值。这样查找一个数据的时间复杂度就是o(1)，一般多用于精确查找。
     *
     * 10.Hash索引和B+树的区别？
     *      因为两者数据结构上的差异导致它们的使用场景也不同，哈希索引一般多用于精确的等值查找，B+索引则多用于除了精确的等值查找外的其他查找。在大多数情况下，会选择使用B+树索引。
     *      (1)哈希索引不支持排序，因为哈希表是无序的。
     *      (2)哈希索引不支持范围查找。
     *      (3)哈希索引不支持模糊查询及多列索引的最左前缀匹配。
     *      (4)因为哈希表中会存在哈希冲突，所以哈希索引的性能是不稳定的，而B+树索引的性能是相对稳定的，每次查询都是从根节点到叶子节点
     *
     * 11.B树和B+树的区别？
     *     B树和B+树最主要的区别主要有两点：
     *          (1)B树中的内部节点和叶子节点均存放键和值，而B+树的内部节点只有键没有值，叶子节点存放所有的键和值。
     *          (2)B＋树的叶子节点是通过相连在一起的，方便顺序检索。
     *
     * 12.数据库为什么使用B+树而不是B树？
     *      B树适用于随机检索，而B+树适用于随机检索和顺序检索
     *      B+树的空间利用率更高，因为B树每个节点要存储键和值，而B+树的内部节点只存储键，这样B+树的一个节点就可以存储更多的索引，从而使树的高度变低，减少了I/O次数，使得数据检索速度更快。
     *      B+树的叶子节点都是连接在一起的，所以范围查找，顺序查找更加方便
     *      B+树的性能更加稳定，因为在B+树中，每次查询都是从根节点到叶子节点，而在B树中，要查询的值可能不在叶子节点，在内部节点就已经找到。
     *
     *      那在什么情况适合使用B树呢，因为B树的内部节点也可以存储值，所以可以把一些频繁访问的值放在距离根节点比较近的地方，这样就可以提高查询效率。综上所述，B+树的性能更加适合作为数据库的索引。
     *
     * 13.什么是聚簇索引，什么是非聚簇索引？
     *      聚簇索引和非聚簇索引最主要的区别是数据和索引是否分开存储。
     *      聚簇索引:
     *          将数据和索引放到一起存储，索引结构的叶子节点保留了数据行。
     *      非聚簇索引：
     *          将数据进和索引分开存储，索引叶子节点存储的是指向数据行的地址。
     */
}
















































