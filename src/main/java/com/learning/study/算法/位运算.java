package com.learning.study.算法;

/**
 * https://blog.csdn.net/kexuanxiu1163/article/details/106368597 盘点：这 7 道位运算面试题，哪一题你能做对？
 */
public class 位运算 {
    /**
     1.位运算基础
        程序中的所有数在计算机内存中都是以二进制的形式储存的，位运算就是直接对整数在内存中的二进制位进行操作。
        详见位运算.png
        &   与       两个位都为1时, 结果才为1
        |   或       两个位都为0时, 结果才为0
        ^   异或      两个位相同为0, 相异为1  (一个数和0异或是他本身, 一个数和-1(二进制全是0)是他对应位数取反)
        ~   取反      0变1, 1变0
        <<  左移      各二进位全部左移若干位, 高位丢弃, 低位补0
        >>  右移      各二进位全部右移若干位, 1.无符号数,高位补0, 2.有符号数, 补符号位(算术右移)或补0(逻辑右移)

     2.位运算的奇淫技巧
        (1)使用 x & 1 == 1 判断奇偶数。（注意，一些编辑器底层会把用%判断奇偶数的代码，自动优化成位运算）
        (2)不使用第三个数，交换两个数。x = x ^ y ， y = x ^ y ， x = x ^ y。（早些年喜欢问到，现在如果谁再问，大家会觉得很low）
        (3)两个相同的数异或的结果是 0，一个数和 0 异或的结果是它本身。（对于找数这块，异或往往有一些别样的用处。）
        (4)x & (x - 1) ，可以将最右边的 1 设置为 0（这个技巧可以用来检测 2的幂，或者检测一个整数二进制中 1 的个数，又或者别人问你一个数变成另一个数其中改变了多少个bit位，统统都是它）
            比如 1 0 1 0 0 可以变成 1 0 0 0 0, 去掉最右边的那个1
            a.判断一个数(x)是否是2的n次方
                原理: 如果一个数是2的n次方，那么这个数用二进制表示时其最高位为1，其余位为0
                (x&(x-1)) == 0
            b.检测一个整数二进制中 1 的个数
                原理: 一个数减去1，则这个数的二进制数中最后一个1及其后的数字取反。 x & (x - 1) 为它的二进制数中少一个1
                 int count(int x) {
                     int count = 0;
                     while ( x ) {
                         x &= (x - 1) ;
                         count++;
                     }
                     return count;
                 }
            c.一个数变成另一个数其中改变了多少个bit位
                原理: 联想到位运算有一个异或操作，相同为0，相异为1，所以问题转变成了计算A异或B之后这个数中1的个数
                 int bit_count(int number1, int number2)
                 {
                 　　int temp = number1 ^ number2;
                 　　int count = 0;
                 　　while (temp) {
                 　　　　temp &= (temp - 1);
                 　　　　count++;
                 　　}
                 　　return count;
                 }
        (5)异或可以被当做无进位加法使用，与操作可以用来获取进位
        (6)i+(~i)=-1，i 取反再与 i 相加，相当于把所有二进制位设为1，其十进制结果为-1
        (7)对于int32而言，使用 n >> 31取得 n 的正负号。并且可以通过 (n ^ (n >> 31)) - (n >> 31) 来得到绝对值。（n为正，n >> 31 的所有位等于0。若n为负数，n >> 31 的所有位等于1，其值等于-1）
            获取绝对值: (n ^ (n >> 31)) - (n >> 31)
        (8)使用 (x ^ y) >= 0 来判断符号是否相同。（如果两个数都是正数,则二进制的第一位均为0,x^y=0；如果两个数都是负数,则二进制的第一位均为1；x^y=0 如果两个数符号相反,则二进制的第一位相反,x^y=1。有0的情况例外，^相同得0，不同得1）
            判断两个数的符号: (x ^ y) >= 0

     3.两数之和
         “异或”是一个无进位加法，说白了就是把进位砍掉。比如01^01=00。
         “与”可以用来获取进位，比如01&01=01，然后再把结果左移一位，就可以获取进位结果。
        列如: 12+7
                        12      1 1 0 0
                        7       0 1 1 1
            12^7        11      1 0 1 1
            12&7<<1     8       1 0 0 0
            11^8        3       0 0 1 1
            11&8<<1     16    1 0 0 0 0
            16^3        19    1 0 0 1 1
            16&3<<1     0     0 0 0 0 0 //结束
        代码:
             public int getSum(int a, int b) {
                 while(b != 0) {
                    int temp = a ^ b;
                    b = (a & b) << 1;
                    a = temp;
                 }
                 return a;
             }

     4.判断一个数是否是 2 的幂次方
        return n > 0 && n&(n-1) == 0

     5.一的个数
        可以用x & (x - 1)来不断消除最右边的1然后计数

     6.只出现一次的数字(给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。)
        利用异或运算, 异或操作满足交换律和结合律, a⊕b⊕a=(a⊕a)⊕b=0⊕b=b
             public int singleNumber(int[] nums) {
                 int ans = nums[0];
                 for (int i = 1; i < nums.length; i++) {
                     ans ^= nums[i];
                 }
                 return ans;
             }

     7.只出现一次的数字Ⅱ (给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现了三次。找出那个只出现了一次的元素)
        (1)这里还有一种数学解法
            原理：[A,A,A,B,B,B,C,C,C] 和 [A,A,A,B,B,B,C]，差了两个C。
            也就是说，如果把原数组去重、再乘以3得到的值，刚好就是要找的元素的2倍
            效果不错，但是仍然使用了额外空间。所以我们还是得使用位运算



     */
}
